using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Runtime.PCG;
using Runtime.Shared;

using UnityEditor;
using Unity.EditorCoroutines.Editor;
using Editors.Shared;

namespace Editors.PCG
{
    /// <summary>
    /// Is used to asyncronously spawn entities generated by selected PCG Biomes or Volumes
    /// </summary>
    public sealed class PCGBatchingSpawnerWindow : EditorWindow
    {
        private enum Mode
        {
            Instant = 0,
            ASYNC = 1
        }

    #region Fields
        private bool _lockTargetVolumes = false;
        private bool _resetBeforeGeneration = true;
        private Mode _mode = Mode.ASYNC;
        private int _asyncBatchSize = 100;
        private int _asyncSleepFrames = 1;

        Queue<PCGVolume> _volumes; // Contains volumes that have not been placed
        private PCGVolume[] _cachedVolumes;
        private PCGBiome[] _biomes;
        private Vector2 _biomesScrollPosition = Vector3.zero;
        private Vector2 _volumesScrollPosition = Vector3.zero;
        private EditorCoroutine _spawningCoroutine;

        private bool _pausedSpawning = false;
        private bool _isSpawning = false;
        private PCGVolume _currentVolume;
        private float _currentSpawnedPercent;

        private int _batchesCompleted;
        private int _objectsSpawned;
        private int _volumesSpawnedFor;

        private int _startingNumVolumes;
        private int _volumesCompleted;
    #endregion Fields

        private void Validate ()
        {
            _asyncBatchSize = Math.Clamp(_asyncBatchSize, 1, 300);
            _asyncSleepFrames = Math.Clamp(_asyncSleepFrames, 1, 4);
        }

        [MenuItem("PCG/Batching Spawner")]
        public static void ShowWindow ()
        {
            GetWindow<PCGBatchingSpawnerWindow>();
        }

        public void OnEnable ()
        {
            titleContent.text = "PCG Batching Spawner";
            _cachedVolumes = null;
            _biomes = null;
        }

        public void OnGUI ()
        {
            _volumes ??= new();
            int volumeCount = _volumes.Count;
            if (!_isSpawning && ((!_lockTargetVolumes) || (_lockTargetVolumes && volumeCount == 0))) FindTargets();

        #region Inspector Outline
            PaintSettings();

            GUILayout.Space(20f);
            PaintControls();

            if (!_isSpawning) {
                GUILayout.Space(10f);
                PaintTargetObjects();
            }

            if (_isSpawning) {
                GUILayout.Space(10f);
                PaintSpawningStatus();
            }

            Validate();
        #endregion Inspector Outline

            void PaintSettings ()
            {
                EditorGUI.BeginDisabledGroup(_isSpawning);
                _lockTargetVolumes = EditorGUILayout.Toggle("Lock Volumes/Biomes", _lockTargetVolumes);
                _resetBeforeGeneration = EditorGUILayout.Toggle("Reset Before Generation", _resetBeforeGeneration);
                _mode = (Mode)EditorGUILayout.EnumPopup("Mode", _mode);
                
                if (_mode == Mode.ASYNC) {
                    _asyncBatchSize = EditorGUILayout.IntField("Batch size", _asyncBatchSize);
                    _asyncSleepFrames = EditorGUILayout.IntSlider("Sleep Frames", _asyncSleepFrames, 1, 4);
                }
                EditorGUI.EndDisabledGroup();
            }

            void PaintTargetObjects ()
            {
                if (_biomes.Length > 0) EditorGUIUtils.DrawDisabledObjectArray(_biomes, ref _biomesScrollPosition, "Biomes");
                if (volumeCount > 0) EditorGUIUtils.DrawDisabledObjectQueue(_volumes, ref _volumesScrollPosition, _isSpawning ? "Queued Volumes" : "Volumes" + (_lockTargetVolumes ? " (Locked)" : ""));
            }

            void PaintControls ()
            {
                if (_isSpawning) {
                    // Spawning in progress
                    GUILayout.BeginHorizontal();
                    EditorGUILayout.HelpBox(_pausedSpawning ? "Spawning is paused" : "Spawning objects in progress...", MessageType.Warning);
                    GUILayout.BeginVertical();
                    if (GUILayout.Button(_pausedSpawning ? "Resume" : "Pause")) _pausedSpawning = !_pausedSpawning;
                    if (GUILayout.Button("Terminate")) TerminateSpawning();
                    GUILayout.EndVertical();
                    GUILayout.EndHorizontal();
                } else {
                    if (volumeCount == 0) EditorGUILayout.HelpBox("Select PCG Biomes or Volumes to continue...", MessageType.Info);
                    EditorGUILayout.BeginHorizontal();
                    EditorGUI.BeginDisabledGroup(_volumes == null || volumeCount == 0);
                    if (GUILayout.Button(_mode == Mode.ASYNC ? "Begin Spawning" : "Spawn")) SpawnEntities();
                    if (GUILayout.Button("Reset All")) ResetAll();
                    EditorGUI.EndDisabledGroup();
                    EditorGUILayout.EndHorizontal();
                }
            }

            void PaintSpawningStatus ()
            {
                // float casts are not redundant and is required for the division to work
                float completed = ((float)_volumesCompleted / (float)_startingNumVolumes) + (Mathf.Clamp01(_currentSpawnedPercent) * (1f / _startingNumVolumes));
                EditorGUI.ProgressBar(EditorGUILayout.GetControlRect(false, EditorGUIUtility.singleLineHeight), completed, "Completed");
                EditorGUI.ProgressBar(EditorGUILayout.GetControlRect(false, EditorGUIUtility.singleLineHeight), _currentSpawnedPercent, "Current");

                // Stats
                EditorGUI.BeginDisabledGroup(true);
                EditorGUILayout.IntField("Completed Volumes", _volumesCompleted);
                EditorGUILayout.IntField("Batches Completed", _batchesCompleted);
                EditorGUILayout.IntField("Spawned", _objectsSpawned);
                EditorGUILayout.ObjectField("Current Volume", _currentVolume, typeof(PCGVolume), false);
                EditorGUI.EndDisabledGroup();
            }
        }

        private void FindTargets ()
        {
            _volumes = new();
            List<PCGBiome> biomes = new();

            foreach (Transform transform in Selection.transforms)
            {
                if (!transform.gameObject.activeInHierarchy) continue;

                // Biomes
                if (transform.TryGetComponent(out PCGBiome biome)) {
                    biome.FindVolumes();
                    biomes.Add(biome);
                    foreach (PCGVolume biomeVolume in biome.Volumes) TryEnqueueVolume(biomeVolume);
                    continue;
                }

                // Volumes
                if (transform.TryGetComponent(out PCGVolume volume)) {
                    TryEnqueueVolume(volume);
                    continue;
                }

                void TryEnqueueVolume (PCGVolume volume)
                {
                    if (volume == null) return;
                    if (!volume.gameObject.activeSelf) return;
                    _volumes.Enqueue(volume);
                }
            }

            _biomes = biomes.ToArray();
        }

        private void SpawnEntities ()
        {
            _startingNumVolumes = _volumes.Count;
            if (_resetBeforeGeneration) foreach (PCGVolume volume in _volumes) volume.ResetPlaced();

            switch (_mode)
            {
                case Mode.Instant:
                    foreach (PCGVolume volume in _volumes) volume.Place();
                    break;

                case Mode.ASYNC:
                    BeginASYNCSpawning();
                    break;
            }
        }

        private void ResetAll ()
        {
            if (_volumes.Count == 0) return;
            foreach (PCGVolume volume in _volumes) volume.ResetPlaced();
        }

        private void BeginASYNCSpawning ()
        {
            Validate();

            if (_lockTargetVolumes) _cachedVolumes = _volumes.ToArray();
            if (_biomes.Length > 0) foreach (PCGBiome biome in _biomes) biome.UpdateVolumeSettings();

            _pausedSpawning = false;

            _volumesSpawnedFor = 0;
            _volumesCompleted = 0;
            _batchesCompleted = 0;
            _objectsSpawned = 0;

            _isSpawning = true;
            PlaceNextVolume();
        }

        private void OnEndASYNCSpawning ()
        {
            _isSpawning = false;
            Debug.Log("PCG: Spawned " + _objectsSpawned + " objects over " + _volumesSpawnedFor + " volume" + (_volumesSpawnedFor > 1 ? 's' : ""));

            if (_lockTargetVolumes) {
                _volumes.Clear();
                foreach (PCGVolume volume in _cachedVolumes) _volumes.Enqueue(volume);
                _cachedVolumes = null;
            }

            Repaint();
        }

        private void TerminateSpawning ()
        {
            EditorCoroutineUtility.StopCoroutine(_spawningCoroutine);
            foreach (PCGVolume volume in _volumes) volume.OnFinishSpawn();
            Debug.Log("PCG: Terminated spawning");
            OnEndASYNCSpawning();
        }

        private void PlaceNextVolume ()
        {
            if (_volumes.Count == 0) {
                Debug.Log("PCG: Finished ASYNC spawning");
                OnEndASYNCSpawning();
                return; // All volumes have been placed
            }

            PCGVolume targetVolume = _volumes.Dequeue();
            _spawningCoroutine = EditorCoroutineUtility.StartCoroutine(SpawnVolumeEntitiesASYNC(targetVolume.Place(true), targetVolume), this);
        }

        private IEnumerator SpawnVolumeEntitiesASYNC (List<PCGPlacementPoint> points, PCGVolume volume)
        {
            if (volume == null || points == null) {
                PlaceNextVolume();
                yield break;
            }

            int pointCount = points.Count;
            if (pointCount == 0) {
                PlaceNextVolume();
                yield break;
            }

            _currentVolume = volume;
            _volumesSpawnedFor++;
            _currentSpawnedPercent = 0f;
            volume.OnBeginSpawn();

            BatchedIterator batchedIterator = new
            (
                pointCount,
                (int accessIndex) =>
                {
                    // Treat the points list as a queue where the first item is spawned and then removed
                    volume.SpawnEntityAt(points[0]);
                    points.RemoveAt(0); 
                    _objectsSpawned++;
                },
                _asyncBatchSize
            );

            while (!batchedIterator.IsDone)
            {
                // Pause and wait until resumed
                if (_pausedSpawning) while (_pausedSpawning) yield return null;

                batchedIterator.Iterate();
                _batchesCompleted++;
                for (int i = 0; i < _asyncSleepFrames; i++) yield return null;

                // float casts are not redundant and is required for the division to work
                _currentSpawnedPercent = (float)batchedIterator.IterationsCompleted / (float)batchedIterator.CollectionSize;
                Repaint();
            }

            _volumesCompleted++;
            volume.OnFinishSpawn();
            PlaceNextVolume();
        }
    }
}